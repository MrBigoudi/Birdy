{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { HashtagMatch } from \"../match/hashtag-match\"; // RegExp objects which are shared by all instances of HashtagMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating HashtagMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nvar matcherRegex = new RegExp(\"#[_\".concat(alphaNumericAndMarksCharsStr, \"]{1,139}(?![_\").concat(alphaNumericAndMarksCharsStr, \"])\"), 'g'); // lookahead used to make sure we don't match something above 139 characters\n\nvar nonWordCharRegex = new RegExp('[^' + alphaNumericAndMarksCharsStr + ']');\n/**\n * @class Autolinker.matcher.Hashtag\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find HashtagMatch matches in an input string.\n */\n\nvar HashtagMatcher =\n/** @class */\nfunction (_super) {\n  __extends(HashtagMatcher, _super);\n  /**\n   * @method constructor\n   * @param {Object} cfg The configuration properties for the Match instance,\n   *   specified in an Object (map).\n   */\n\n\n  function HashtagMatcher(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /**\n     * @cfg {String} serviceName\n     *\n     * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n     * for available values.\n     */\n\n\n    _this.serviceName = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * The regular expression to match Hashtags. Example match:\n     *\n     *     #asdf\n     *\n     * @protected\n     * @property {RegExp} matcherRegex\n     */\n\n    _this.matcherRegex = matcherRegex;\n    /**\n     * The regular expression to use to check the character before a username match to\n     * make sure we didn't accidentally match an email address.\n     *\n     * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n     *\n     * @protected\n     * @property {RegExp} nonWordCharRegex\n     */\n\n    _this.nonWordCharRegex = nonWordCharRegex;\n    _this.serviceName = cfg.serviceName;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  HashtagMatcher.prototype.parseMatches = function (text) {\n    var matcherRegex = this.matcherRegex,\n        nonWordCharRegex = this.nonWordCharRegex,\n        serviceName = this.serviceName,\n        tagBuilder = this.tagBuilder,\n        matches = [],\n        match;\n\n    while ((match = matcherRegex.exec(text)) !== null) {\n      var offset = match.index,\n          prevChar = text.charAt(offset - 1); // If we found the match at the beginning of the string, or we found the match\n      // and there is a whitespace char in front of it (meaning it is not a '#' char\n      // in the middle of a word), then it is a hashtag match.\n\n      if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n        var matchedText = match[0],\n            hashtag = match[0].slice(1); // strip off the '#' character at the beginning\n\n        matches.push(new HashtagMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: offset,\n          serviceName: serviceName,\n          hashtag: hashtag\n        }));\n      }\n    }\n\n    return matches;\n  };\n\n  return HashtagMatcher;\n}(Matcher);\n\nexport { HashtagMatcher };","map":{"version":3,"mappings":";AAAA,SAASA,OAAT,QAAuC,WAAvC;AAEA,SAASC,4BAAT,QAA6C,cAA7C;AACA,SAASC,YAAT,QAA6B,wBAA7B,C,CAGA;AACA;AACA;AACA;AACA;;AACA,IAAMC,YAAY,GAAG,IAAIC,MAAJ,CAAY,aAAMH,4BAAN,EAAkC,eAAlC,EAAkCI,MAAlC,CAAkDJ,4BAAlD,EAA8E,IAA9E,CAAZ,EAAgG,GAAhG,CAArB,C,CAA6H;;AAC7H,IAAMK,gBAAgB,GAAG,IAAIF,MAAJ,CAAY,OAAOH,4BAAP,GAAsC,GAAlD,CAAzB;AAEA;;;;;;;AAMA;AAAA;AAAA;AAAoCM;AAgCnC;;;;;;;AAKA,0BAAaC,GAAb,EAAsC;AAAtC,gBACCC,kBAAOD,GAAP,KAAY,IADb;AAnCA;;;;;;;;AAMmBE,wBAA+B,SAA/B,CA6BmB,CA7BwB;;AAE9D;;;;;;;;;AAQUA,yBAAeP,YAAf;AAEV;;;;;;;;;;AASUO,6BAAmBJ,gBAAnB;AAWTI,SAAI,CAACC,WAAL,GAAmBH,GAAG,CAACG,WAAvB;;AACA;AAGD;;;;;AAGAC,oDAAcC,IAAd,EAA0B;AACzB,QAAIV,YAAY,GAAG,KAAKA,YAAxB;AAAA,QACIG,gBAAgB,GAAG,KAAKA,gBAD5B;AAAA,QAEIK,WAAW,GAAG,KAAKA,WAFvB;AAAA,QAGIG,UAAU,GAAG,KAAKA,UAHtB;AAAA,QAIIC,OAAO,GAAY,EAJvB;AAAA,QAKIC,KALJ;;AAOA,WAAO,CAAEA,KAAK,GAAGb,YAAY,CAACc,IAAb,CAAmBJ,IAAnB,CAAV,MAA0C,IAAjD,EAAwD;AACvD,UAAIK,MAAM,GAAGF,KAAK,CAACG,KAAnB;AAAA,UACIC,QAAQ,GAAGP,IAAI,CAACQ,MAAL,CAAaH,MAAM,GAAG,CAAtB,CADf,CADuD,CAIvD;AACA;AACA;;AACA,UAAIA,MAAM,KAAK,CAAX,IAAgBZ,gBAAgB,CAACgB,IAAjB,CAAuBF,QAAvB,CAApB,EAAwD;AACvD,YAAIG,WAAW,GAAGP,KAAK,CAAE,CAAF,CAAvB;AAAA,YACIQ,OAAO,GAAGR,KAAK,CAAE,CAAF,CAAL,CAAWS,KAAX,CAAkB,CAAlB,CADd,CADuD,CAEjB;;AAEtCV,eAAO,CAACW,IAAR,CAAc,IAAIxB,YAAJ,CAAkB;AAC/BY,oBAAU,EAAIA,UADiB;AAE/BS,qBAAW,EAAGA,WAFiB;AAG/BL,gBAAM,EAAQA,MAHiB;AAI/BP,qBAAW,EAAGA,WAJiB;AAK/Ba,iBAAO,EAAOA;AALiB,SAAlB,CAAd;AAOA;AACD;;AAED,WAAOT,OAAP;AACA,GA9BD;;AAgCD;AAAC,CA/ED,CAAoCf,OAApC","names":["Matcher","alphaNumericAndMarksCharsStr","HashtagMatch","matcherRegex","RegExp","concat","nonWordCharRegex","__extends","cfg","_super","_this","serviceName","HashtagMatcher","text","tagBuilder","matches","match","exec","offset","index","prevChar","charAt","test","matchedText","hashtag","slice","push"],"sources":["../src/matcher/hashtag-matcher.ts"],"sourcesContent":["import { Matcher, MatcherConfig } from \"./matcher\";\nimport { HashtagServices } from \"../autolinker\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { HashtagMatch } from \"../match/hashtag-match\";\nimport { Match } from \"../match/match\";\n\n// RegExp objects which are shared by all instances of HashtagMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating HashtagMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nconst matcherRegex = new RegExp( `#[_${alphaNumericAndMarksCharsStr}]{1,139}(?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 139 characters\nconst nonWordCharRegex = new RegExp( '[^' + alphaNumericAndMarksCharsStr + ']' );\n\n/**\n * @class Autolinker.matcher.Hashtag\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find HashtagMatch matches in an input string.\n */\nexport class HashtagMatcher extends Matcher {\n\n\t/**\n\t * @cfg {String} serviceName\n\t *\n\t * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n\t * for available values.\n\t */\n\tprotected readonly serviceName: HashtagServices = 'twitter';  // default value just to get the above doc comment in the ES5 output and documentation generator\n\n\t/**\n\t * The regular expression to match Hashtags. Example match:\n\t *\n\t *     #asdf\n\t *\n\t * @protected\n\t * @property {RegExp} matcherRegex\n\t */\n\tprotected matcherRegex = matcherRegex;\n\n\t/**\n\t * The regular expression to use to check the character before a username match to\n\t * make sure we didn't accidentally match an email address.\n\t *\n\t * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n\t *\n\t * @protected\n\t * @property {RegExp} nonWordCharRegex\n\t */\n\tprotected nonWordCharRegex = nonWordCharRegex;\n\n\n\t/**\n\t * @method constructor\n\t * @param {Object} cfg The configuration properties for the Match instance,\n\t *   specified in an Object (map).\n\t */\n\tconstructor( cfg: HashtagMatcherConfig ) {\n\t\tsuper( cfg );\n\n\t\tthis.serviceName = cfg.serviceName;\n\t}\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tlet matcherRegex = this.matcherRegex,\n\t\t    nonWordCharRegex = this.nonWordCharRegex,\n\t\t    serviceName = this.serviceName,\n\t\t    tagBuilder = this.tagBuilder,\n\t\t    matches: Match[] = [],\n\t\t    match: RegExpExecArray | null;\n\n\t\twhile( ( match = matcherRegex.exec( text ) ) !== null ) {\n\t\t\tlet offset = match.index,\n\t\t\t    prevChar = text.charAt( offset - 1 );\n\n\t\t\t// If we found the match at the beginning of the string, or we found the match\n\t\t\t// and there is a whitespace char in front of it (meaning it is not a '#' char\n\t\t\t// in the middle of a word), then it is a hashtag match.\n\t\t\tif( offset === 0 || nonWordCharRegex.test( prevChar ) ) {\n\t\t\t\tlet matchedText = match[ 0 ],\n\t\t\t\t    hashtag = match[ 0 ].slice( 1 );  // strip off the '#' character at the beginning\n\n\t\t\t\tmatches.push( new HashtagMatch( {\n\t\t\t\t\ttagBuilder  : tagBuilder,\n\t\t\t\t\tmatchedText : matchedText,\n\t\t\t\t\toffset      : offset,\n\t\t\t\t\tserviceName : serviceName,\n\t\t\t\t\thashtag     : hashtag\n\t\t\t\t} ) );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n}\n\nexport interface HashtagMatcherConfig extends MatcherConfig {\n\tserviceName: HashtagServices\n}"]},"metadata":{},"sourceType":"module"}