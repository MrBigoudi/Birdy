{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { MentionMatch } from \"../match/mention-match\"; // RegExp objects which are shared by all instances of MentionMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating MentionMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nvar twitterRegex = new RegExp(\"@[_\".concat(alphaNumericAndMarksCharsStr, \"]{1,50}(?![_\").concat(alphaNumericAndMarksCharsStr, \"])\"), 'g'); // lookahead used to make sure we don't match something above 50 characters\n\nvar instagramRegex = new RegExp(\"@[_.\".concat(alphaNumericAndMarksCharsStr, \"]{1,30}(?![_\").concat(alphaNumericAndMarksCharsStr, \"])\"), 'g'); // lookahead used to make sure we don't match something above 30 characters\n\nvar soundcloudRegex = new RegExp(\"@[-_.\".concat(alphaNumericAndMarksCharsStr, \"]{1,50}(?![-_\").concat(alphaNumericAndMarksCharsStr, \"])\"), 'g'); // lookahead used to make sure we don't match something above 50 characters\n// TikTok usernames are 1-24 characters containing letters, numbers, underscores\n// and periods, but cannot end in a period: https://support.tiktok.com/en/getting-started/setting-up-your-profile/changing-your-username\n\nvar tiktokRegex = new RegExp(\"@[_.\".concat(alphaNumericAndMarksCharsStr, \"]{1,23}[_\").concat(alphaNumericAndMarksCharsStr, \"](?![_\").concat(alphaNumericAndMarksCharsStr, \"])\"), 'g'); // lookahead used to make sure we don't match something above 24 characters\n\nvar nonWordCharRegex = new RegExp('[^' + alphaNumericAndMarksCharsStr + ']');\n/**\n * @class Autolinker.matcher.Mention\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find/replace username matches in an input string.\n */\n\nvar MentionMatcher =\n/** @class */\nfunction (_super) {\n  __extends(MentionMatcher, _super);\n  /**\n   * @method constructor\n   * @param {Object} cfg The configuration properties for the Match instance,\n   *   specified in an Object (map).\n   */\n\n\n  function MentionMatcher(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /**\n     * @cfg {'twitter'/'instagram'/'soundcloud'} protected\n     *\n     * The name of service to link @mentions to.\n     *\n     * Valid values are: 'twitter', 'instagram', 'soundcloud', or 'tiktok'\n     */\n\n\n    _this.serviceName = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\n     * Hash of regular expression to match username handles. Example match:\n     *\n     *     @asdf\n     *\n     * @private\n     * @property {Object} matcherRegexes\n     */\n\n    _this.matcherRegexes = {\n      'twitter': twitterRegex,\n      'instagram': instagramRegex,\n      'soundcloud': soundcloudRegex,\n      'tiktok': tiktokRegex\n    };\n    /**\n     * The regular expression to use to check the character before a username match to\n     * make sure we didn't accidentally match an email address.\n     *\n     * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n     *\n     * @private\n     * @property {RegExp} nonWordCharRegex\n     */\n\n    _this.nonWordCharRegex = nonWordCharRegex;\n    _this.serviceName = cfg.serviceName;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  MentionMatcher.prototype.parseMatches = function (text) {\n    var serviceName = this.serviceName,\n        matcherRegex = this.matcherRegexes[this.serviceName],\n        nonWordCharRegex = this.nonWordCharRegex,\n        tagBuilder = this.tagBuilder,\n        matches = [],\n        match;\n\n    if (!matcherRegex) {\n      return matches;\n    }\n\n    while ((match = matcherRegex.exec(text)) !== null) {\n      var offset = match.index,\n          prevChar = text.charAt(offset - 1); // If we found the match at the beginning of the string, or we found the match\n      // and there is a whitespace char in front of it (meaning it is not an email\n      // address), then it is a username match.\n\n      if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n        var matchedText = match[0].replace(/\\.+$/g, ''),\n            // strip off trailing .\n        mention = matchedText.slice(1); // strip off the '@' character at the beginning\n\n        matches.push(new MentionMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: offset,\n          serviceName: serviceName,\n          mention: mention\n        }));\n      }\n    }\n\n    return matches;\n  };\n\n  return MentionMatcher;\n}(Matcher);\n\nexport { MentionMatcher };","map":{"version":3,"mappings":";AAAA,SAASA,OAAT,QAAuC,WAAvC;AACA,SAASC,4BAAT,QAA6C,cAA7C;AAEA,SAASC,YAAT,QAA6B,wBAA7B,C,CAGA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,YAAY,GAAG,IAAIC,MAAJ,CAAY,aAAMH,4BAAN,EAAkC,cAAlC,EAAkCI,MAAlC,CAAiDJ,4BAAjD,EAA6E,IAA7E,CAAZ,EAA+F,GAA/F,CAArB,C,CAA4H;;AAE5H,IAAMK,cAAc,GAAG,IAAIF,MAAJ,CAAY,cAAOH,4BAAP,EAAmC,cAAnC,EAAmCI,MAAnC,CAAkDJ,4BAAlD,EAA8E,IAA9E,CAAZ,EAAgG,GAAhG,CAAvB,C,CAA+H;;AAE/H,IAAMM,eAAe,GAAG,IAAIH,MAAJ,CAAY,eAAQH,4BAAR,EAAoC,eAApC,EAAoCI,MAApC,CAAoDJ,4BAApD,EAAgF,IAAhF,CAAZ,EAAkG,GAAlG,CAAxB,C,CAAkI;AAElI;AACA;;AACA,IAAMO,WAAW,GAAG,IAAIJ,MAAJ,CAAY,cAAOH,4BAAP,EAAmC,WAAnC,EAAmCI,MAAnC,CAA+CJ,4BAA/C,EAA2E,QAA3E,EAA2EI,MAA3E,CAAoFJ,4BAApF,EAAgH,IAAhH,CAAZ,EAAkI,GAAlI,CAApB,C,CAA8J;;AAE9J,IAAMQ,gBAAgB,GAAG,IAAIL,MAAJ,CAAY,OAAOH,4BAAP,GAAsC,GAAlD,CAAzB;AAEA;;;;;;;AAMA;AAAA;AAAA;AAAoCS;AAsCnC;;;;;;;AAKA,0BAAaC,GAAb,EAAsC;AAAtC,gBACCC,kBAAOD,GAAP,KAAY,IADb;AAzCA;;;;;;;;;AAOUE,wBAA+B,SAA/B,CAkC4B,CAlCe;;AAErD;;;;;;;;;AAQmBA,2BAA0C;AAC5D,iBAAWV,YADiD;AAE5D,mBAAaG,cAF+C;AAG5D,oBAAcC,eAH8C;AAI5D,gBAAUC;AAJkD,KAA1C;AAOnB;;;;;;;;;;AASmBK,6BAAmBJ,gBAAnB;AAWlBI,SAAI,CAACC,WAAL,GAAmBH,GAAG,CAACG,WAAvB;;AACA;AAGD;;;;;AAGAC,oDAAcC,IAAd,EAA0B;AACzB,QAAIF,WAAW,GAAG,KAAKA,WAAvB;AAAA,QACIG,YAAY,GAAG,KAAKC,cAAL,CAAqB,KAAKJ,WAA1B,CADnB;AAAA,QAEIL,gBAAgB,GAAG,KAAKA,gBAF5B;AAAA,QAGIU,UAAU,GAAG,KAAKA,UAHtB;AAAA,QAIIC,OAAO,GAAY,EAJvB;AAAA,QAKIC,KALJ;;AAOA,QAAI,CAACJ,YAAL,EAAmB;AAClB,aAAOG,OAAP;AACA;;AAED,WAAO,CAAEC,KAAK,GAAGJ,YAAY,CAACK,IAAb,CAAmBN,IAAnB,CAAV,MAA0C,IAAjD,EAAwD;AACvD,UAAIO,MAAM,GAAGF,KAAK,CAACG,KAAnB;AAAA,UACIC,QAAQ,GAAGT,IAAI,CAACU,MAAL,CAAaH,MAAM,GAAG,CAAtB,CADf,CADuD,CAIvD;AACA;AACA;;AACA,UAAIA,MAAM,KAAK,CAAX,IAAgBd,gBAAgB,CAACkB,IAAjB,CAAuBF,QAAvB,CAApB,EAAwD;AACvD,YAAIG,WAAW,GAAGP,KAAK,CAAE,CAAF,CAAL,CAAWQ,OAAX,CAAoB,OAApB,EAA6B,EAA7B,CAAlB;AAAA,YAAqD;AACjDC,eAAO,GAAGF,WAAW,CAACG,KAAZ,CAAmB,CAAnB,CADd,CADuD,CAEhB;;AAEvCX,eAAO,CAACY,IAAR,CAAc,IAAI9B,YAAJ,CAAkB;AAC/BiB,oBAAU,EAAMA,UADe;AAE/BS,qBAAW,EAAKA,WAFe;AAG/BL,gBAAM,EAAUA,MAHe;AAI/BT,qBAAW,EAAKA,WAJe;AAK/BgB,iBAAO,EAASA;AALe,SAAlB,CAAd;AAOA;AACD;;AAED,WAAOV,OAAP;AACA,GAlCD;;AAoCD;AAAC,CAzFD,CAAoCpB,OAApC","names":["Matcher","alphaNumericAndMarksCharsStr","MentionMatch","twitterRegex","RegExp","concat","instagramRegex","soundcloudRegex","tiktokRegex","nonWordCharRegex","__extends","cfg","_super","_this","serviceName","MentionMatcher","text","matcherRegex","matcherRegexes","tagBuilder","matches","match","exec","offset","index","prevChar","charAt","test","matchedText","replace","mention","slice","push"],"sources":["/home/yannis/Documents/Project/Birdy/birdy-client/node_modules/autolinker/dist/es2015/src/matcher/mention-matcher.ts"],"sourcesContent":["import { Matcher, MatcherConfig } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { MentionServices } from \"../autolinker\";\nimport { MentionMatch } from \"../match/mention-match\";\nimport { Match } from \"../match/match\";\n\n// RegExp objects which are shared by all instances of MentionMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating MentionMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nconst twitterRegex = new RegExp( `@[_${alphaNumericAndMarksCharsStr}]{1,50}(?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 50 characters\n\nconst instagramRegex = new RegExp( `@[_.${alphaNumericAndMarksCharsStr}]{1,30}(?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 30 characters\n\nconst soundcloudRegex = new RegExp( `@[-_.${alphaNumericAndMarksCharsStr}]{1,50}(?![-_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 50 characters\n\n// TikTok usernames are 1-24 characters containing letters, numbers, underscores\n// and periods, but cannot end in a period: https://support.tiktok.com/en/getting-started/setting-up-your-profile/changing-your-username\nconst tiktokRegex = new RegExp( `@[_.${alphaNumericAndMarksCharsStr}]{1,23}[_${alphaNumericAndMarksCharsStr}](?![_${alphaNumericAndMarksCharsStr}])`, 'g' );  // lookahead used to make sure we don't match something above 24 characters\n\nconst nonWordCharRegex = new RegExp( '[^' + alphaNumericAndMarksCharsStr + ']' );\n\n/**\n * @class Autolinker.matcher.Mention\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find/replace username matches in an input string.\n */\nexport class MentionMatcher extends Matcher {\n\n\t/**\n\t * @cfg {'twitter'/'instagram'/'soundcloud'} protected\n\t * \n\t * The name of service to link @mentions to.\n\t * \n\t * Valid values are: 'twitter', 'instagram', 'soundcloud', or 'tiktok'\n\t */\n\tprotected serviceName: MentionServices = 'twitter';  // default value just to get the above doc comment in the ES5 output and documentation generator\n\n\t/**\n\t * Hash of regular expression to match username handles. Example match:\n\t *\n\t *     @asdf\n\t *\n\t * @private\n\t * @property {Object} matcherRegexes\n\t */\n\tprotected readonly matcherRegexes: {[key: string]: RegExp} = {\n\t\t'twitter': twitterRegex,\n\t\t'instagram': instagramRegex,\n\t\t'soundcloud': soundcloudRegex,\n\t\t'tiktok': tiktokRegex\n\t};\n\n\t/**\n\t * The regular expression to use to check the character before a username match to\n\t * make sure we didn't accidentally match an email address.\n\t *\n\t * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n\t *\n\t * @private\n\t * @property {RegExp} nonWordCharRegex\n\t */\n\tprotected readonly nonWordCharRegex = nonWordCharRegex;\n\n\n\t/**\n\t * @method constructor\n\t * @param {Object} cfg The configuration properties for the Match instance,\n\t *   specified in an Object (map).\n\t */\n\tconstructor( cfg: MentionMatcherConfig ) {\n\t\tsuper( cfg );\n\n\t\tthis.serviceName = cfg.serviceName;\n\t}\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tlet serviceName = this.serviceName,\n\t\t    matcherRegex = this.matcherRegexes[ this.serviceName ],\n\t\t    nonWordCharRegex = this.nonWordCharRegex,\n\t\t    tagBuilder = this.tagBuilder,\n\t\t    matches: Match[] = [],\n\t\t    match: RegExpExecArray | null;\n\n\t\tif (!matcherRegex) {\n\t\t\treturn matches;\n\t\t}\n\n\t\twhile( ( match = matcherRegex.exec( text ) ) !== null ) {\n\t\t\tlet offset = match.index,\n\t\t\t    prevChar = text.charAt( offset - 1 );\n\n\t\t\t// If we found the match at the beginning of the string, or we found the match\n\t\t\t// and there is a whitespace char in front of it (meaning it is not an email\n\t\t\t// address), then it is a username match.\n\t\t\tif( offset === 0 || nonWordCharRegex.test( prevChar ) ) {\n\t\t\t\tlet matchedText = match[ 0 ].replace( /\\.+$/g, '' ), // strip off trailing .\n\t\t\t\t    mention = matchedText.slice( 1 );  // strip off the '@' character at the beginning\n\n\t\t\t\tmatches.push( new MentionMatch( {\n\t\t\t\t\ttagBuilder    : tagBuilder,\n\t\t\t\t\tmatchedText   : matchedText,\n\t\t\t\t\toffset        : offset,\n\t\t\t\t\tserviceName   : serviceName,\n\t\t\t\t\tmention       : mention\n\t\t\t\t} ) );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n}\n\n\nexport interface MentionMatcherConfig extends MatcherConfig {\n\tserviceName: MentionServices\n}"]},"metadata":{},"sourceType":"module"}