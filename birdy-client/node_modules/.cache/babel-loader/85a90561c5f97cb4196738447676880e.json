{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\"; // For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nvar localPartCharRegex = new RegExp(\"[\".concat(alphaNumericAndMarksCharsStr, \"!#$%&'*+/=?^_`{|}~-]\"));\nvar strictTldRegex = new RegExp(\"^\".concat(tldRegex.source, \"$\"));\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\n\nvar EmailMatcher =\n/** @class */\nfunction (_super) {\n  __extends(EmailMatcher, _super);\n\n  function EmailMatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * Valid characters that can be used in the \"local\" part of an email address,\n     * i.e. the \"name\" part of \"name@site.com\"\n     */\n\n\n    _this.localPartCharRegex = localPartCharRegex;\n    /**\n     * Stricter TLD regex which adds a beginning and end check to ensure\n     * the string is a valid TLD\n     */\n\n    _this.strictTldRegex = strictTldRegex;\n    return _this;\n  }\n  /**\n   * @inheritdoc\n   */\n\n\n  EmailMatcher.prototype.parseMatches = function (text) {\n    var tagBuilder = this.tagBuilder,\n        localPartCharRegex = this.localPartCharRegex,\n        strictTldRegex = this.strictTldRegex,\n        matches = [],\n        len = text.length,\n        noCurrentEmailMatch = new CurrentEmailMatch(); // for matching a 'mailto:' prefix\n\n    var mailtoTransitions = {\n      'm': 'a',\n      'a': 'i',\n      'i': 'l',\n      'l': 't',\n      't': 'o',\n      'o': ':'\n    };\n    var charIdx = 0,\n        state = 0\n    /* NonEmailMatch */\n    ,\n        currentEmailMatch = noCurrentEmailMatch; // For debugging: search for other \"For debugging\" lines\n    // const table = new CliTable( {\n    // \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n    // } );\n\n    while (charIdx < len) {\n      var char = text.charAt(charIdx); // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n\n      switch (state) {\n        case 0\n        /* NonEmailMatch */\n        :\n          stateNonEmailAddress(char);\n          break;\n\n        case 1\n        /* Mailto */\n        :\n          stateMailTo(text.charAt(charIdx - 1), char);\n          break;\n\n        case 2\n        /* LocalPart */\n        :\n          stateLocalPart(char);\n          break;\n\n        case 3\n        /* LocalPartDot */\n        :\n          stateLocalPartDot(char);\n          break;\n\n        case 4\n        /* AtSign */\n        :\n          stateAtSign(char);\n          break;\n\n        case 5\n        /* DomainChar */\n        :\n          stateDomainChar(char);\n          break;\n\n        case 6\n        /* DomainHyphen */\n        :\n          stateDomainHyphen(char);\n          break;\n\n        case 7\n        /* DomainDot */\n        :\n          stateDomainDot(char);\n          break;\n\n        default:\n          throwUnhandledCaseError(state);\n      } // For debugging: search for other \"For debugging\" lines\n      // table.push( \n      // \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n      // );\n\n\n      charIdx++;\n    } // Capture any valid match at the end of the string\n\n\n    captureMatchIfValidAndReset(); // For debugging: search for other \"For debugging\" lines\n    //console.log( '\\n' + table.toString() );\n\n    return matches; // Handles the state when we're not in an email address\n\n    function stateNonEmailAddress(char) {\n      if (char === 'm') {\n        beginEmailMatch(1\n        /* Mailto */\n        );\n      } else if (localPartCharRegex.test(char)) {\n        beginEmailMatch();\n      } else {// not an email address character, continue\n      }\n    } // Handles if we're reading a 'mailto:' prefix on the string\n\n\n    function stateMailTo(prevChar, char) {\n      if (prevChar === ':') {\n        // We've reached the end of the 'mailto:' prefix\n        if (localPartCharRegex.test(char)) {\n          state = 2\n          /* LocalPart */\n          ;\n          currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n            hasMailtoPrefix: true\n          }));\n        } else {\n          // we've matched 'mailto:' but didn't get anything meaningful\n          // immediately afterwards (for example, we encountered a \n          // space character, or an '@' character which formed 'mailto:@'\n          resetToNonEmailMatchState();\n        }\n      } else if (mailtoTransitions[prevChar] === char) {// We're currently reading the 'mailto:' prefix, stay in\n        // Mailto state\n      } else if (localPartCharRegex.test(char)) {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // different character that didn't continue the prefix\n        state = 2\n        /* LocalPart */\n        ;\n      } else if (char === '.') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // dot character\n        state = 3\n        /* LocalPartDot */\n        ;\n      } else if (char === '@') {\n        // We we're reading a prefix of 'mailto:', but encountered a\n        // an @ character\n        state = 4\n        /* AtSign */\n        ;\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    } // Handles the state when we're currently in the \"local part\" of an \n    // email address (as opposed to the \"domain part\")\n\n\n    function stateLocalPart(char) {\n      if (char === '.') {\n        state = 3\n        /* LocalPartDot */\n        ;\n      } else if (char === '@') {\n        state = 4\n        /* AtSign */\n        ;\n      } else if (localPartCharRegex.test(char)) {// stay in the \"local part\" of the email address\n      } else {\n        // not an email address character, return to \"NonEmailAddress\" state\n        resetToNonEmailMatchState();\n      }\n    } // Handles the state where we've read \n\n\n    function stateLocalPartDot(char) {\n      if (char === '.') {\n        // We read a second '.' in a row, not a valid email address \n        // local part\n        resetToNonEmailMatchState();\n      } else if (char === '@') {\n        // We read the '@' character immediately after a dot ('.'), not \n        // an email address\n        resetToNonEmailMatchState();\n      } else if (localPartCharRegex.test(char)) {\n        state = 2\n        /* LocalPart */\n        ;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n\n    function stateAtSign(char) {\n      if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ;\n      } else {\n        // Anything else, not an email address\n        resetToNonEmailMatchState();\n      }\n    }\n\n    function stateDomainChar(char) {\n      if (char === '.') {\n        state = 7\n        /* DomainDot */\n        ;\n      } else if (char === '-') {\n        state = 6\n        /* DomainHyphen */\n        ;\n      } else if (domainNameCharRegex.test(char)) {// Stay in the DomainChar state\n      } else {\n        // Anything else, we potentially matched if the criteria has\n        // been met\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function stateDomainHyphen(char) {\n      if (char === '-' || char === '.') {\n        // Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ;\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function stateDomainDot(char) {\n      if (char === '.' || char === '-') {\n        // not valid to have two dots (\"..\") or dot+hypen (\".-\")\n        captureMatchIfValidAndReset();\n      } else if (domainNameCharRegex.test(char)) {\n        state = 5\n        /* DomainChar */\n        ; // After having read a '.' and then a valid domain character,\n        // we now know that the domain part of the email is valid, and\n        // we have found at least a partial EmailMatch (however, the\n        // email address may have additional characters from this point)\n\n        currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), {\n          hasDomainDot: true\n        }));\n      } else {\n        // Anything else\n        captureMatchIfValidAndReset();\n      }\n    }\n\n    function beginEmailMatch(newState) {\n      if (newState === void 0) {\n        newState = 2\n        /* LocalPart */\n        ;\n      }\n\n      state = newState;\n      currentEmailMatch = new CurrentEmailMatch({\n        idx: charIdx\n      });\n    }\n\n    function resetToNonEmailMatchState() {\n      state = 0\n      /* NonEmailMatch */\n      ;\n      currentEmailMatch = noCurrentEmailMatch;\n    }\n    /*\n     * Captures the current email address as an EmailMatch if it's valid,\n     * and resets the state to read another email address.\n     */\n\n\n    function captureMatchIfValidAndReset() {\n      if (currentEmailMatch.hasDomainDot) {\n        // we need at least one dot in the domain to be considered a valid email address\n        var matchedText = text.slice(currentEmailMatch.idx, charIdx); // If we read a '.' or '-' char that ended the email address\n        // (valid domain name characters, but only valid email address\n        // characters if they are followed by something else), strip \n        // it off now\n\n        if (/[-.]$/.test(matchedText)) {\n          matchedText = matchedText.slice(0, -1);\n        }\n\n        var emailAddress = currentEmailMatch.hasMailtoPrefix ? matchedText.slice('mailto:'.length) : matchedText; // if the email address has a valid TLD, add it to the list of matches\n\n        if (doesEmailHaveValidTld(emailAddress)) {\n          matches.push(new EmailMatch({\n            tagBuilder: tagBuilder,\n            matchedText: matchedText,\n            offset: currentEmailMatch.idx,\n            email: emailAddress\n          }));\n        }\n      }\n\n      resetToNonEmailMatchState();\n      /**\n       * Determines if the given email address has a valid TLD or not\n       * @param {string} emailAddress - email address\n       * @return {Boolean} - true is email have valid TLD, false otherwise\n       */\n\n      function doesEmailHaveValidTld(emailAddress) {\n        var emailAddressTld = emailAddress.split('.').pop() || '';\n        var emailAddressNormalized = emailAddressTld.toLowerCase();\n        var isValidTld = strictTldRegex.test(emailAddressNormalized);\n        return isValidTld;\n      }\n    }\n  };\n\n  return EmailMatcher;\n}(Matcher);\n\nexport { EmailMatcher };\n\nvar CurrentEmailMatch =\n/** @class */\nfunction () {\n  function CurrentEmailMatch(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    this.idx = cfg.idx !== undefined ? cfg.idx : -1;\n    this.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n    this.hasDomainDot = !!cfg.hasDomainDot;\n  }\n\n  return CurrentEmailMatch;\n}();","map":{"version":3,"mappings":"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","names":["Matcher","alphaNumericAndMarksCharsStr","domainNameCharRegex","EmailMatch","throwUnhandledCaseError","tldRegex","localPartCharRegex","RegExp","strictTldRegex","source","__extends","_this","EmailMatcher","text","tagBuilder","matches","len","length","noCurrentEmailMatch","CurrentEmailMatch","mailtoTransitions","charIdx","state","currentEmailMatch","char","charAt","stateNonEmailAddress","stateMailTo","stateLocalPart","stateLocalPartDot","stateAtSign","stateDomainChar","stateDomainHyphen","stateDomainDot","captureMatchIfValidAndReset","beginEmailMatch","test","prevChar","__assign","hasMailtoPrefix","resetToNonEmailMatchState","hasDomainDot","newState","idx","matchedText","slice","emailAddress","doesEmailHaveValidTld","push","offset","email","emailAddressTld","split","pop","emailAddressNormalized","toLowerCase","isValidTld","cfg","undefined"],"sources":["/home/yannis/Documents/Project/Birdy/birdy-client/node_modules/autolinker/dist/es2015/src/matcher/email-matcher.ts"],"sourcesContent":["import { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr, domainNameCharRegex } from \"../regex-lib\";\nimport { EmailMatch } from \"../match/email-match\";\nimport { Match } from \"../match/match\";\nimport { throwUnhandledCaseError } from '../utils';\nimport { tldRegex } from \"./tld-regex\";\n\n// For debugging: search for other \"For debugging\" lines\n// import CliTable from 'cli-table';\n\n// RegExp objects which are shared by all instances of EmailMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating EmailMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\nconst localPartCharRegex = new RegExp( `[${alphaNumericAndMarksCharsStr}!#$%&'*+/=?^_\\`{|}~-]` );\nconst strictTldRegex = new RegExp( `^${tldRegex.source}$` );\n\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nexport class EmailMatcher extends Matcher {\n\n\t/**\n\t * Valid characters that can be used in the \"local\" part of an email address,\n\t * i.e. the \"name\" part of \"name@site.com\"\n\t */\n\tprotected localPartCharRegex = localPartCharRegex;\n\n\t/**\n\t * Stricter TLD regex which adds a beginning and end check to ensure\n\t * the string is a valid TLD\n\t */\n\tprotected strictTldRegex = strictTldRegex;\n\n\n\t/**\n\t * @inheritdoc\n\t */\n\tparseMatches( text: string ) {\n\t\tconst tagBuilder = this.tagBuilder,\n\t\t\t  localPartCharRegex = this.localPartCharRegex,\n\t\t\t  strictTldRegex = this.strictTldRegex,\n\t\t\t  matches: Match[] = [],\n\t\t\t  len = text.length,\n\t\t\t  noCurrentEmailMatch = new CurrentEmailMatch();\n\n\t\t// for matching a 'mailto:' prefix\n\t\tconst mailtoTransitions = {\n\t\t\t'm': 'a',\n\t\t\t'a': 'i',\n\t\t\t'i': 'l',\n\t\t\t'l': 't',\n\t\t\t't': 'o',\n\t\t\t'o': ':',\n\t\t};\n\n\t\tlet charIdx = 0,\n\t\t\tstate = State.NonEmailMatch as State,\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t// const table = new CliTable( {\n\t\t// \thead: [ 'charIdx', 'char', 'state', 'charIdx', 'currentEmailAddress.idx', 'hasDomainDot' ]\n\t\t// } );\n\n\t\twhile( charIdx < len ) {\n\t\t\tconst char = text.charAt( charIdx );\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tswitch( state ) {\n\t\t\t\tcase State.NonEmailMatch: stateNonEmailAddress( char ); break;\n\n\t\t\t\tcase State.Mailto: \n\t\t\t\t\tstateMailTo( text.charAt( charIdx - 1 ) as MailtoChar, char ); \n\t\t\t\t\tbreak;\n\t\t\t\tcase State.LocalPart: stateLocalPart( char ); break;\n\t\t\t\tcase State.LocalPartDot: stateLocalPartDot( char ); break;\n\t\t\t\tcase State.AtSign: stateAtSign( char ); break;\n\t\t\t\tcase State.DomainChar: stateDomainChar( char ); break;\n\t\t\t\tcase State.DomainHyphen: stateDomainHyphen( char ); break;\n\t\t\t\tcase State.DomainDot: stateDomainDot( char ); break;\n\t\n\t\t\t\tdefault: \n\t\t\t\t\tthrowUnhandledCaseError( state );\n\t\t\t}\n\n\t\t\t// For debugging: search for other \"For debugging\" lines\n\t\t\t// table.push( \n\t\t\t// \t[ charIdx, char, State[ state ], charIdx, currentEmailAddress.idx, currentEmailAddress.hasDomainDot ] \n\t\t\t// );\n\n\t\t\tcharIdx++;\n\t\t}\n\n\t\t// Capture any valid match at the end of the string\n\t\tcaptureMatchIfValidAndReset();\n\n\t\t// For debugging: search for other \"For debugging\" lines\n\t\t//console.log( '\\n' + table.toString() );\n\t\t\n\t\treturn matches;\n\n\n\t\t// Handles the state when we're not in an email address\n\t\tfunction stateNonEmailAddress( char: string ) {\n\t\t\tif( char === 'm' ) {\n\t\t\t\tbeginEmailMatch( State.Mailto );\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tbeginEmailMatch();\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, continue\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles if we're reading a 'mailto:' prefix on the string\n\t\tfunction stateMailTo( prevChar: MailtoChar, char: string ) {\n\t\t\tif( prevChar === ':' ) {\n\t\t\t\t// We've reached the end of the 'mailto:' prefix\n\t\t\t\tif( localPartCharRegex.test( char ) ) {\n\t\t\t\t\tstate = State.LocalPart;\n\t\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\t\thasMailtoPrefix: true \n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// we've matched 'mailto:' but didn't get anything meaningful\n\t\t\t\t\t// immediately afterwards (for example, we encountered a \n\t\t\t\t\t// space character, or an '@' character which formed 'mailto:@'\n\t\t\t\t\tresetToNonEmailMatchState();\n\t\t\t\t}\n\n\t\t\t} else if( mailtoTransitions[ prevChar ] === char ) {\n\t\t\t\t// We're currently reading the 'mailto:' prefix, stay in\n\t\t\t\t// Mailto state\n\t\t\t\t\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// different character that didn't continue the prefix\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else if( char === '.' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// dot character\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We we're reading a prefix of 'mailto:', but encountered a\n\t\t\t\t// an @ character\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state when we're currently in the \"local part\" of an \n\t\t// email address (as opposed to the \"domain part\")\n\t\tfunction stateLocalPart( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.LocalPartDot;\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\tstate = State.AtSign;\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\t// stay in the \"local part\" of the email address\n\n\t\t\t} else {\n\t\t\t\t// not an email address character, return to \"NonEmailAddress\" state\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\t// Handles the state where we've read \n\t\tfunction stateLocalPartDot( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\t// We read a second '.' in a row, not a valid email address \n\t\t\t\t// local part\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( char === '@' ) {\n\t\t\t\t// We read the '@' character immediately after a dot ('.'), not \n\t\t\t\t// an email address\n\t\t\t\tresetToNonEmailMatchState();\n\n\t\t\t} else if( localPartCharRegex.test( char ) ) {\n\t\t\t\tstate = State.LocalPart;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction stateAtSign( char: string ) {\n\t\t\tif( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else, not an email address\n\t\t\t\tresetToNonEmailMatchState();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainChar( char: string ) {\n\t\t\tif( char === '.' ) {\n\t\t\t\tstate = State.DomainDot;\n\n\t\t\t} else if( char === '-' ) {\n\t\t\t\tstate = State.DomainHyphen;\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\t// Stay in the DomainChar state\n\n\t\t\t} else {\n\t\t\t\t// Anything else, we potentially matched if the criteria has\n\t\t\t\t// been met\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainHyphen( char: string ) {\n\t\t\tif( char === '-' || char === '.' ) {\n\t\t\t\t// Not valid to have two hyphens (\"--\") or hypen+dot (\"-.\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\t\tfunction stateDomainDot( char: string ) {\n\t\t\tif( char === '.' || char === '-' ) {\n\t\t\t\t// not valid to have two dots (\"..\") or dot+hypen (\".-\")\n\t\t\t\tcaptureMatchIfValidAndReset();\n\n\t\t\t} else if( domainNameCharRegex.test( char ) ) {\n\t\t\t\tstate = State.DomainChar;\n\n\t\t\t\t// After having read a '.' and then a valid domain character,\n\t\t\t\t// we now know that the domain part of the email is valid, and\n\t\t\t\t// we have found at least a partial EmailMatch (however, the\n\t\t\t\t// email address may have additional characters from this point)\n\t\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { \n\t\t\t\t\t...currentEmailMatch, \n\t\t\t\t\thasDomainDot: true \n\t\t\t\t} );\n\n\t\t\t} else {\n\t\t\t\t// Anything else\n\t\t\t\tcaptureMatchIfValidAndReset();\n\t\t\t}\n\t\t}\n\n\n\t\tfunction beginEmailMatch( newState = State.LocalPart ) {\n\t\t\tstate = newState;\n\t\t\tcurrentEmailMatch = new CurrentEmailMatch( { idx: charIdx } );\n\t\t}\n\n\t\tfunction resetToNonEmailMatchState() {\n\t\t\tstate = State.NonEmailMatch;\n\t\t\tcurrentEmailMatch = noCurrentEmailMatch;\n\t\t}\n\n\n\n\t\t/*\n\t\t * Captures the current email address as an EmailMatch if it's valid,\n\t\t * and resets the state to read another email address.\n\t\t */\n\t\tfunction captureMatchIfValidAndReset() {\n\t\t\tif( currentEmailMatch.hasDomainDot ) {  // we need at least one dot in the domain to be considered a valid email address\n\t\t\t\tlet matchedText = text.slice( currentEmailMatch.idx, charIdx );\n\n\t\t\t\t// If we read a '.' or '-' char that ended the email address\n\t\t\t\t// (valid domain name characters, but only valid email address\n\t\t\t\t// characters if they are followed by something else), strip \n\t\t\t\t// it off now\n\t\t\t\tif( /[-.]$/.test( matchedText ) ){\n\t\t\t\t\tmatchedText = matchedText.slice( 0, -1 );\n\t\t\t\t}\n\n\t\t\t\tconst emailAddress = currentEmailMatch.hasMailtoPrefix \n\t\t\t\t\t? matchedText.slice( 'mailto:'.length ) \n\t\t\t\t\t: matchedText;\n\n\t\t\t\t// if the email address has a valid TLD, add it to the list of matches\n\t\t\t\tif ( doesEmailHaveValidTld( emailAddress ) ) {\n\t\t\t\t\tmatches.push( new EmailMatch( {\n\t\t\t\t\t\ttagBuilder  : tagBuilder,\n\t\t\t\t\t\tmatchedText : matchedText,\n\t\t\t\t\t\toffset      : currentEmailMatch.idx,\n\t\t\t\t\t\temail       : emailAddress\n\t\t\t\t\t} ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresetToNonEmailMatchState();\n\t\t\n\n\t\t/**\n\t\t * Determines if the given email address has a valid TLD or not\n\t\t * @param {string} emailAddress - email address\n\t\t * @return {Boolean} - true is email have valid TLD, false otherwise\n\t\t */\n\t\tfunction doesEmailHaveValidTld( emailAddress: string ) {\n\t\t\tconst emailAddressTld : string = emailAddress.split( '.' ).pop() || '';\n\t\t\tconst emailAddressNormalized = emailAddressTld.toLowerCase();\n\t\t\tconst isValidTld = strictTldRegex.test( emailAddressNormalized );\n\n\t\t\treturn isValidTld;\n\t\t}}\n\t}\n\n}\n\ntype MailtoChar = 'm' | 'a' | 'i' | 'l' | 't' | 'o' | ':';\n\nconst enum State {\n\tNonEmailMatch = 0,\n\t\n\tMailto,  // if matching a 'mailto:' prefix\n\tLocalPart,\n\tLocalPartDot,\n\tAtSign,\n\tDomainChar,\n\tDomainHyphen,\n\tDomainDot\n}\n\nclass CurrentEmailMatch {\n\treadonly idx: number;  // the index of the first character in the email address\n\treadonly hasMailtoPrefix: boolean;\n\treadonly hasDomainDot: boolean;\n\n\tconstructor( cfg: Partial<CurrentEmailMatch> = {} ) {\n\t\tthis.idx = cfg.idx !== undefined ? cfg.idx : -1;\n\t\tthis.hasMailtoPrefix = !!cfg.hasMailtoPrefix;\n\t\tthis.hasDomainDot = !!cfg.hasDomainDot;\n\t}\n}"]},"metadata":{},"sourceType":"module"}